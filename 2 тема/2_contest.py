from math import sqrt, ceil

# 1 задание
# /////////////////////////////////////////////////////////////////////////////////////////////////
def getCountPairs():
    ##Ввод с консоли
    ## int для преобразования в целое число
    n = int(input())
    ## arr - создаю массив для хранения переменных
    arr = []
    ## счётчик в цикле
    j = 0
    while (j < n):
        ## увеличение переменной счётчика для прохождения цикла
        j += 1
        ## добавлление целого числа с консоли в конец массива
        arr.append(int(input()))
    # Вводим счётчик для количества пар чисел
    counterPairs = 0
    ## проходим в цикле по всем элементам массива от 1 первого элемента (1 элемент индекс = 0,
    ##  последний элемент индекс = длина массива(размер, количество элементов) - 1
    for i in range(0, n-1):
        #проверка делимости на 7(пар чисел)
        if arr[i]%7==0 or arr[i+1]%7==0:
            counterPairs += 1
    return resSum;

## Вызов функции print выведет в консоль количество пар getCountPairs вернёт количество пар чисел
print(getCountPairs())
# /////////////////////////////////////////////////////////////////////////////////////////////////

# 2 задание
# /////////////////////////////////////////////////////////////////////////////////////////////////
##Получаемы коэфы квадратного уравнения с консоли
a = float(input())
b = float(input())
c = float(input())
# дискриминант
d = b ** 2 - 4 * a * c

if d > 0:
    try:
        if a == 0:
            print(round(-c / b, 3))
        else:
            x1 = (-b + d ** 0.5) / (2 * a)
            x2 = (-b - d ** 0.5) / (2 * a)
            print(round(x1, 3), round(x2, 3))
    except:
        print('ERROR')
elif d == 0:
    try:
        ##round - округдление числа(1 параметр - число которое нужно округлить,
        ##2 число - количество знаков которое мы оставляем)
        print(round(-b / (2 * a), 3), round(-b / (2 * a), 3))
    except:
        print('ERROR')
else:
    print('ERROR')
# /////////////////////////////////////////////////////////////////////////////////////////////////

# 3 задние
# /////////////////////////////////////////////////////////////////////////////////////////////////
def getSumDivisorsFour(num):
    # проверка на ноль
    if num == 0:
        return 0
    # Количество нулей числа
    counter = 0
    # Сумма цифр числа делящихся на 4
    result = 0

    while num != 0:
        razrad = num % 10
        if razrad % 4 == 0:
            result += razrad
        if razrad == 0:
            counter += 1
        num //= 10
    return (result if (result or counter) else "No")

print(getSumDivisorsFour(abs(int(input()))))
# /////////////////////////////////////////////////////////////////////////////////////////////////

# 4 задание
# /////////////////////////////////////////////////////////////////////////////////////////////////
def minDivisors(num):
    ##Создаём массив для хранения сумм
    sum = []

    ## Проходим в цикле от 1 до квадратного корня
    # Квадратный корень потому что делители больше корня будут меняться местами
    # например делители 16: [1, 2, 4, 8, 16] => соответственно 1* 16, 2*8, 4*4, 8*2, 16*1
    # Последние 2 произведения нам на фиг не сдались их отсекаем с помощью корня
    for i in range(1, ceil(sqrt(num))):
        if(i == ceil(sqrt(num))):
            sum.append(i*2)
        if (num % i == 0):
            # i - 1 делитель числа num, num/i - 2 делитель числа num
            sum.append(i+int(num/i))
    # Возвращаем минимальный элемент массива(минмиальную сумму)
    return int(min(sum))
print(minDivisors(int(input())))
# /////////////////////////////////////////////////////////////////////////////////////////////////

# 5 задание
# /////////////////////////////////////////////////////////////////////////////////////////////////
# Вспомогательная функция для проверки чисел на простоту
def isPrimeNum(n):
    for i in range(2, n):
        if n % i == 0:
            return False
    return True

def nearestNumber():
    # Получаем число с консоли
    n = int(input())
    # создаем массив в котором будут храниться два числа, предыдущее и следующее простое
    arr = []
    # если число изначальное простое добавляем это же самое число в массив(см. 1 пример в задании)
    if isPrimeNum(n):
        arr.append(n)
        arr.append(n)
    else:
        # находим предыдущее простое
        while True:
            n -= 1
            if (isPrimeNum(n)):
                arr.append(n)
                break
        # находим следующее простое
        while True:
            n += 1
            if (isPrimeNum(n)):
                arr.append(n)
                break

    print(arr[0], arr[1])

nearestNumber()
# /////////////////////////////////////////////////////////////////////////////////////////////////


